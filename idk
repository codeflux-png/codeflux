_G.niggywiggystatus = false 

if _G.niggywiggystatus then
    local filepath = "CODEFLUX_HOOP_NATION_CONFIGS.json"
    local function saveConfig()
    local config = {
        InfiniteStamina = _G.infstam or false,
        AutoRelease = _G.autoreal or false,
        ReleaseTimer = _G.releasetimer or 0.5,
        AutoGuard = _G.autog or false,
        NameChange = _G.namechange or nil,
        UIColor = _G.uicolor or {R = 255, G = 1, B = 255},
    }
    writefile(filepath, game:GetService("HttpService"):JSONEncode(config))
end

local function loadConfig()
    if isfile(filepath) then
        local config = game:GetService("HttpService"):JSONDecode(readfile(filepath))
        return config
    end
    return nil
end

local config = loadConfig()

if game.CoreGui:FindFirstChild("ui") then
    game.CoreGui.ui:Destroy()
end

local lib = loadstring(game:HttpGet"https://raw.githubusercontent.com/dawid-scripts/UI-Libs/main/Vape.txt")()

local win = lib:Window("Codeflux | Hoop Nation | v1.00", Color3.fromRGB(44, 120, 224))
local tab = win:Tab("Main")

tab:Toggle("Infinite Stamina", config and config.InfiniteStamina or false, function(infstam)
    _G.infstam = infstam
    saveConfig()

    local player = game.Players.LocalPlayer
    local character = player.Character

    if character then
        local lowerTorso = character:FindFirstChild("LowerTorso")
        if lowerTorso then
            local stamina = lowerTorso:FindFirstChild("Stamina")
            if stamina then
                local runStamina = stamina:FindFirstChild("RunStamina")
                if runStamina then
                    runStamina.Enabled = not infstam
                else
                    print("RunStamina not found")
                end
            else
                print("Stamina object not found in LowerTorso")
            end
        else
            print("LowerTorso not found in character")
        end
    else
        print("Player character not found")
    end
end)

tab:Toggle("Auto Release", config and config.AutoRelease or false, function(release)
    _G.autoreal = release
    saveConfig()
    print(release)
end)

_G.autoreal = config and config.AutoRelease or false
_G.releasetimer = config and config.ReleaseTimer or 0.5

-- Services
local Players = game:GetService("Players")
local InputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Debounce to prevent repeated triggering
local debounce = false

-- Function to handle key presses
local function onKeyPress(input)
    if _G.autoreal and not debounce then
        if input.UserInputType == Enum.UserInputType.Gamepad1 then
            if input.KeyCode == Enum.KeyCode.ButtonX then
                -- Xbox controller input (Button X)
                debounce = true
                wait(_G.releasetimer)
                VirtualInputManager:SendKeyEvent(false, "ButtonX", false, game)
                debounce = false
            elseif input.KeyCode == Enum.KeyCode.ButtonSquare then
                -- PS4 controller input (Button Square)
                debounce = true
                wait(_G.releasetimer)
                VirtualInputManager:SendKeyEvent(false, "ButtonSquare", false, game)
                debounce = false
            end
        elseif input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == Enum.KeyCode.E then
            -- Keyboard input (Key E)
            debounce = true
            wait(_G.releasetimer)
            VirtualInputManager:SendKeyEvent(false, "E", false, game)
            debounce = false
        end
    end
end

-- Connect the key press function to the input began event
InputService.InputBegan:Connect(onKeyPress)

tab:Slider("Release Adjustment", 0, 15, config and config.ReleaseTimer * 10 or 5, function(adjustment)
    local decimalValue = adjustment / 10
    game.CoreGui.ui.Main.TabFolder.Tab.Slider.SliderValue.Text = _G.releasetimer
    _G.releasetimer = decimalValue
    saveConfig()
    print(decimalValue)
    game.CoreGui.ui.Main.TabFolder.Tab.Slider.SliderValue.Text = decimalValue
    game.CoreGui.ui.Main.TabFolder.Tab.Slider.SliderValue.Text = _G.releasetimer
end)

game.CoreGui.ui.Main.TabFolder.Tab.Slider.SliderValue.Text = _G.releasetimer


local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer
local character = localPlayer.Character or localPlayer.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid")
local humanoidRootPart = character:WaitForChild("HumanoidRootPart")
local minDistance = 1.3



-- Function to get the closest player
local function getClosestPlayer()
    local closestPlayer = nil
    local shortestDistance = math.huge

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local targetRootPart = player.Character.HumanoidRootPart
            local distance = (targetRootPart.Position - humanoidRootPart.Position).Magnitude

            if distance < shortestDistance then
                shortestDistance = distance
                closestPlayer = player
            end
        end
    end

    return closestPlayer
end

-- Function to move towards the front of the closest player and face them
local function moveToFrontOfClosestPlayer()
    if _G.autog then
        local closestPlayer = getClosestPlayer()
        if closestPlayer and closestPlayer.Character and closestPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local targetRootPart = closestPlayer.Character.HumanoidRootPart
            local targetLookVector = targetRootPart.CFrame.LookVector
            local targetPosition = targetRootPart.Position + targetLookVector * minDistance  -- Move in front of the target
            local lookAtTarget = CFrame.new(targetPosition, targetRootPart.Position)
            localPlayer.Character:SetPrimaryPartCFrame(lookAtTarget)
            humanoid:MoveTo(targetPosition)
        end
    end
end

local LEFT_TRIGGER = Enum.KeyCode.ButtonL2  -- Left trigger on Xbox controller

-- Variable to track if moving to player
local movingToPlayer = false

-- Function to check if a gamepad input is from an Xbox controller
local function isXboxController(inputObject)
    return inputObject.UserInputType == Enum.UserInputType.Gamepad1 or
           inputObject.UserInputType == Enum.UserInputType.Gamepad2 or
           inputObject.UserInputType == Enum.UserInputType.Gamepad3 or
           inputObject.UserInputType == Enum.UserInputType.Gamepad4
end

-- Function to handle input began events
UserInputService.InputBegan:Connect(function(input, gameProcessedEvent)
    if input.KeyCode == Enum.KeyCode.G and not gameProcessedEvent then
        movingToPlayer = true
    elseif isXboxController(input) and input.KeyCode == LEFT_TRIGGER and not gameProcessedEvent then
        movingToPlayer = true
    end
end)

-- Function to handle input ended events
UserInputService.InputEnded:Connect(function(input, gameProcessedEvent)
    if input.KeyCode == Enum.KeyCode.G then
        movingToPlayer = false
    elseif isXboxController(input) and input.KeyCode == LEFT_TRIGGER then
        movingToPlayer = false
    end
end)
-- Update player movement every frame while the key is held down
RunService.RenderStepped:Connect(function()
    if movingToPlayer then
        moveToFrontOfClosestPlayer()
    end
end)

-- Ensure character reference is updated if the character respawns
localPlayer.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid")
    humanoidRootPart = character:WaitForChild("HumanoidRootPart")
end)

-- UI Toggle Integration
tab:Toggle("Auto Guard", _G.autog or false, function(guardstat)
    _G.autog = guardstat
    saveConfig()  -- Ensure you have a saveConfig function that saves the stateard:", guardstat)
end)

local tab = win:Tab("Misc")
local function updateNameLabel()
    local Players = game.Players
    local Player = Players.LocalPlayer
    local Char = Player.Character or Player.CharacterAdded:Wait()
    local Head = Char:WaitForChild("Head")
    local NameTag = Head:WaitForChild("NameTag")
    local NameLabel = NameTag:WaitForChild("NameLabel")

    -- Change the text if _G.namechange is set
    if _G.namechange then
        NameLabel.Text = _G.namechange
    end
end


tab:Textbox("Name Change", _G.namechange or "", function(spoofname)
    _G.namechange = spoofname
    saveConfig()

    -- Ensure the player's character and head are loaded
    local Players = game.Players
    local Player = Players.LocalPlayer
    local Char = Player.Character or Player.CharacterAdded:Wait()
    local Head = Char:WaitForChild("Head")
    local NameTag = Head:WaitForChild("NameTag")
    local NameLabel = NameTag:WaitForChild("NameLabel")

    -- Change the text
    NameLabel.Text = _G.namechange
updateNameLabel()
end)





local settings = win:Tab("Settings")

settings:Bind("Toggle UI", Enum.KeyCode.LeftAlt, function()
    game.CoreGui.ui.Main.Visible = not game.CoreGui.ui.Main.Visible
end)

local initialColor = config and config.UIColor and Color3.fromRGB(config.UIColor.R, config.UIColor.G, config.UIColor.B) or Color3.fromRGB(255, 1, 255)
settings:Colorpicker("Change UI Color", initialColor, function(t)
    _G.uicolor = {R = t.R * 255, G = t.G * 255, B = t.B * 255}
    saveConfig()
    lib:ChangePresetColor(Color3.fromRGB(_G.uicolor.R, _G.uicolor.G, _G.uicolor.B))
end)

local CoreGui = game:GetService("CoreGui")

local gradientColors = {
    ColorSequenceKeypoint.new(0, Color3.fromRGB(_G.uicolor.R, _G.uicolor.G, _G.uicolor.B)),
    ColorSequenceKeypoint.new(0.245, Color3.fromRGB(_G.uicolor.R, _G.uicolor.G, _G.uicolor.B)),
    ColorSequenceKeypoint.new(0.3, Color3.fromRGB(169, 169, 169)),
    ColorSequenceKeypoint.new(0.6, Color3.fromRGB(169, 169, 169)),
    ColorSequenceKeypoint.new(0.64, Color3.fromRGB(169, 169, 169)),
    ColorSequenceKeypoint.new(0.66, Color3.fromRGB(_G.uicolor.R, _G.uicolor.G, _G.uicolor.B)),
    ColorSequenceKeypoint.new(0.67, Color3.fromRGB(169, 169, 169)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(169, 169, 169))
}

local uiGradient = Instance.new("UIGradient")
uiGradient.Color = ColorSequence.new(gradientColors)

local title = CoreGui:WaitForChild("ui"):WaitForChild("Main"):WaitForChild("Title")

uiGradient.Parent = title

title.TextColor3 = Color3.new(1, 1, 1)

local tab = win:Tab("Credits")



else
print('why u tryna bypass')
end
